# Empire ERP. Занимательная бухгалтерия: PostgreSQL

Содержание цикла статей: https://github.com/nomhoi/empire-erp.

Попробуем спроектировать базу данных модуля "Бухгалтерия" на PostgreSQL.


## Настройка проекта

Клонируем проект с гитхаба:
```bash
git clone https://github.com/nomhoi/empire-erp.git
```

Заходим в папку **reaserch/day2/**.

## Step 1. Главная книга

Запустим базу данных и выполним тесты:

```bash
docker-compose run test
```

В проекте используется библиотека **pytest-postgresql**. С помощью этой библиотеки создаются фиксации в виде баз данных, которые используются в качестве шаблонов при создании баз данных для каждого теста.

В данном случае создается фиксация на базе **code/step1.sql**:

```sql
!INCLUDE "code/step1.sql"
```
Здесь мы создаем таблицу главной книги **general_ledger** и добавляем в нее три проводки.

test_step1.py:

```python
!INCLUDE "code/test_step1.py"
```

Можно выполнить sql запросы вручную. Подключимся к базе данных **empire-erp**:
```bash
docker exec -it db psql -U postgres -d empire-erp
```
Выполняем команду в командной строке **psql** для инициализации базы данных для первого шага:
```
empire-erp=# \i step1.sql
```

Выполняем запрос для получения списка проводок из главной книги:
```sql
!INCLUDE "code/step1_1.cmd"
!INCLUDE "code/step1_1.out"
```

Для получения списка проводок по счету 1 можно выполнить такой запрос:

```sql
!INCLUDE "code/step1_2.cmd"
!INCLUDE "code/step1_2.out"
```
Или создать функцию **account_entries** :
```sql
!INCLUDE "code/step1_3.sql"
```

Выполним команду:
```
empire-erp=# \i step1_3.sql
```

Выполним запрос:
```sql
!INCLUDE "code/step1_3.cmd"
!INCLUDE "code/step1_3.out"
```

## Step 2. Оборотная ведомость и баланс

Как и в предыдущей статье - все транзакции выполняются в одном отчетном периоде, в начале периода остатки отсутствуют.

Выполним команду:
```
empire-erp=# \i step2.sql
```

Для определения оборотов по счетам выполним такой запрос:
```sql
!INCLUDE "code/step2_1.cmd"
!INCLUDE "code/step2_1.out"
```

Оборотная ведомость
```sql
!INCLUDE "code/step2_2.cmd"
!INCLUDE "code/step2_2.out"
```

Баланс мы получаем из двух последних столбцов оборотной ведомости. Для проверки просуммируем значения столбцов и сверим полученные суммы друг с другом, они должны совпадать. Это уже несложно и я не буду здесь приводить код.

Проблемы со сторно, которая была в прошлой статье сейчас не должно быть, не проверял.

## Step 3. Проверка добавления проводок

На активных счетах остатки могут быть только по дебету, а на пассивных - по кредиту. Будем проверять такие условия.

### 3.1 Проверка уже заполненной главной книги

Допустим, мы занесли все проводки в главную книгу и нужно проверить их на вышеупомянутое условие. Для этого нужно хранить остатки по дебету и кредиту на счетах.

Если пишем на PL/pgSQL, то для хранения остатков по счетам мы можем использовать таблицу с такой структурой:

```sql
!INCLUDE "code/step3_1.cmx"
```
Если пишем на PL/Python, то можем использовать словарь. Если пишем на C++ - unordered_map.

Алгоритмы проверки остатков на активных и пассивных счетах и обновления остатков на всех счетах в таблице остатков для разных типов счетов различаются. Нужно определять типы счетов каждой проводки. Для определения типа проводки в таблицу плана счетов **coa** (chart of accounts) добавим поле для типа счета: **account_type**:
```sql
!INCLUDE "code/step3_2.cmx"
```
И каким-то образом будем определять с помощью специальной функции. На С++ можно опять использовать unordered_map.

Алгоритмы проверки и определения остатков приводились в прошлой статье, не буду здесь их повторять. Если обнаружится ошибка, то можно поднять исключение и вывести информацию об ошибке.

### 3.2 Проверка на каждом вводе проводки

Можно проверять проводки в момент занесения их в главную книгу. Это можно выполнить с помощью триггерной функции. Триггерная функция будет выполняться после ввода проводки в главную книгу. В случае возникновения ошибки поднимется исключение и транзакция откатится.

На Python и C++ нужно иметь в виду, что в PostgreSQL соединения являются отдельными процессами, поэтому структуру с  остатками нужно хранить в разделяемой между процессами памяти и координировать ее обновление.

### 3.3 Другие ошибки

В этой статье [https://en.wikipedia.org/wiki/Trial_balance](https://en.wikipedia.org/wiki/Trial_balance) указываются несколько ошибок в разделе Limitations. Первая ошибка в нашем случае не проявится, поскольку данные берутся только из главной книги:

> An error of original entry is when both sides of a transaction include the wrong amount.[2] For example, if a purchase invoice for £21 is entered as £12, this will result in an incorrect debit entry (to purchases), and an incorrect credit entry (to the relevant creditor account), both for £9 less, so the total of both columns will be £9 less, and will thus balance.

Остальные ошибки из этой статьи еще не разобрал. Кто разберет и разъяснит всем, тому зарезервирую планету.

## Step 4. Резюме

Как видим, мы можем всю логику модуля "Бухгалтерия" реализовать на стороне сервера базы данных и создать SQL API.
На следующем дне рассмотрим аналитические счета и неможко покодируем на UML.


## Step 5. Занимательное

В этой книге [Artificial Intelligence. A Modern Approach](http://aima.cs.berkeley.edu/newchap00.pdf) есть глава **Automated Planning**. Поскольку ERP про планирование, то имеет смысл добраться до этой главы.

Здесь [https://ит-гранты.рф/2](https://xn----8sbis2aqlf5f.xn--p1ai/2) в конкурсной документации в приложении #3 видим, что ERP системы имеют приоритет 1-го порядка, надо посмотреть требования.



